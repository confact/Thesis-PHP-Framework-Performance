\documentclass{llncs}
\usepackage{fixmetodonotes}
\usepackage[T1]{fontenc}
\usepackage[swedish]{babel}
\usepackage{graphicx}
\usepackage{pdfpages} 
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\usepackage{verbatim} 
\usepackage{minted}

\definecolor{javared}{rgb}{0.6,0,0} % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35} % comments
\definecolor{javapurple}{rgb}{0.5,0,0.35} % keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % javadoc

\lstset{language=PHP,
basicstyle=\ttfamily,
keywordstyle=\color{javapurple}\bfseries,
stringstyle=\color{javared},
commentstyle=\color{javagreen},
morecomment=[s][\color{javadocblue}]{/**}{*/},
columns=fixed,
numbers=left,
numberstyle=\tiny\color{black},
stepnumber=2,
numbersep=10pt,
tabsize=4,
 breaklines=true,
showspaces=false,
showstringspaces=false}
\usepackage[pdftex,bookmarks=true,bookmarksopen,bookmarksdepth=2]{hyperref}
\begin{document}
\hypersetup{
    bookmarks=true,         % show bookmarks bar?
    unicode=false,          % non-Latin characters in Acrobat?s bookmarks
    pdftoolbar=true,        % show Acrobat?s toolbar?
    pdfmenubar=true,        % show Acrobat?s menu?
    pdfnewwindow=true,      % links in new window
    hidelinks
}
\renewcommand\figurename{Figure}
\renewcommand\tablename{Table}
\renewcommand\listfigurename{Figures}
\renewcommand\listtablename{Tables}
\pagenumbering{arabic}
\title{PHP Framework Performance for Web Development}
%\titlerunning{PHP Framework Performance}  
% abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Håkan Nylén}
%
%\authorrunning{Håkan Nylén}   % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
%\tocauthor{Håkan Nylén}
%
\institute{Blekinge Institute of Technology, Karlskrona, Sweden,\\
\email{hakan@dun.se}}

\date{21 March, 2012}

\maketitle
% A category with the (minimum) three required fields
%\category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
%\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

%\terms{Theory}
\renewcommand{\abstractname}{Abstract.}
\pagestyle {plain}
\begin{abstract}
{\bf [Context]} PHP Frameworks, such as CakePHP and Codeigniter, have become popular among developers, since they offer ease of development save time and provide already made libraries to use. 
Considering that more and more websites are built using these frameworks it is important to know how they impact the performance of the website. 
Comparing the two top frameworks with each other can shed some light on what the performance looks like today on the web with PHP as its base. 
{\bf [Problem]} Visitors nowadays have less patience to wait for a website to load. Meanwhile, PHP Framework has become known among developers, but the part of the performance that reduces the load time even more so visitors can surf without any problems, is missing. Therefore, it is a good idea to try to discover how the performance of the PHP Framework can change and improve the visitor experience.
{\bf [Contribution]} In this paper is a description of one of the first performance experiments on PHP Frameworks.
It can help people make the right decision regarding PHP Framework in the future. 
The lack of data in this area is also one of the decisions to make this paper as well.
\end{abstract}
\section{Introduction}
The internet became popular in the beginning of the 90s. 
Different websites, running on HTTP-servers and based on the official HTML language, were the face outwardly seen by visitors. 
And there were discussion about the ability to store and perform calculations on data on websites, but it was not possible to do such with static files like HTML.
However, you could use several languages to do so. The Founder of PHP, Rasmus Lerdorf, used PERL to create PHP because of the massive amount of code you needed to code in PERL.\cite{php:faq} At first there were only small PERL codes in order to make coding a website easier than before.
He created PHP for his own personal need in his quest for the best possible webpage. 
He released it just for fun and it became famous as a good idea to a simplify web development. 
His idea has become and is still today a popular project, a script language that increasingly is becoming object-oriented, if not already.

The web is different nowadays. Many are talking about speed and performance. 
There are different ways to make the website faster, because when the page loading is to slow you will lose visitors. 
% FIX!
A new service, by the name of cloud, has become famous and everyone want to use it, for example CDN\footnote{CDN is Content Delivery Network, a network of servers. 
Where static data for websites and more can be stored, a CDN is spread all over the world, making the request faster.} shows have cloud can be used. Except CDN there are also other different performance approaches, like the web-server, the server in general or the page. 
This could mean configuration or tweaks making the page load faster.
% END FIX!

PHP Framework, i.e. libraries and helpers, mainly focuses on making the development of websites faster. 
This makes it very popular among developers wanting to make a fast demo page for a new project. 
When the page later is up for production on a website, everyone can reach it.
At this stage it is important to think about performance, because users do not wait long for a page to load, like most did in the 90s because of the slow internet connection. 
PHP Framework has help the development of websites but the important point, which is faster websites for the visitors, is still missing.

{\bf The research focus} is an evaluations of web performances in general and on testing the most used and scientifically researched tool to evaluate two of the biggest PHP Frameworks, CodeIgniter and CakePHP.

{\bf The goal} of this thesis is to specifically define a way to start thinking about the performance of PHP Frameworks and web performance in general.

{\bf The expected outcome} of this thesis is to be able to point the developer in the right direction when evaluating PHP Frameworks, and the tests can been seen as guidelines for future work and an initial contribution to get any real data on the performance for PHP Frameworks. 

\section{The Background}
Evaluation in this paper is all about the performance of the load\footnote{load means how long a request takes in milliseconds (ms).}, but it can be hardware, network and more. 
Evaluation in general is how you can test the performance in what way. 
This is very important in the choice of products nowadays.

The story began when the PHP (PHP: Hypertext Preprocessor) was born in 1995 
and this was only a beginning. 
Now PHP is bigger and mainly a ``programming language'' in itself, more called a script language\cite{php:faq} for websites, inspired by Java, C, and PERL. \cite{php:faq} 
Developers using PHP have issues making better and faster websites, so therefore some developers have started to develop PHP Frameworks in order to help create better websites faster. 
There are two PHP Frameworks that have the most users, one is CodeIgniter  \cite{MVC:codeigniter}, which was first released on 28 February 2006 \cite{php:codeigniter}. 
It is focused on creating clean, fast framework for developers. 
The other Framework is CakePHP\cite{MVC:cakephp}, which was released in 2005. CakePHP is mainly inspired by Ruby on Rails. \cite{php:cakephp} 
\newpage
\subsection{MVC}
Model View Controller is a pattern that consisting of 3 different of types of classes, each class summarises what they will do. \cite{MVC:phpTeam} 
Model manages datahandling, like data from databases. 
View manages how the data should be shown for the user. 
Controller is the middle component, collecting data from Model and making the data readable before sending it to the View. 
This paper will be about testing the performance of CodeIgniter\cite{MVC:codeigniter} and CakePHP\cite{MVC:cakephp}.

An example of a webpage with MVC could be a news page. A user uses a web browser to access the website, which connects to the controller as seen in point 1, in Figure \ref{fig:mvcmodel}. Controller needs data from the database so it will call a function in the model-class, as seen in point 2. The model connects to the database and handles the queries and is returning the data to the controller as seen in point 3. Controller then contacts and retrieves View, that mostly contains HTML and only uses PHP to loop out the data and returns it to the user as seen in point 4.
\begin{figure}[h]
\centering
\includegraphics[scale=0.75]{mvc-diagram.eps}
\caption{A simple example of an MVC structure}
\label{fig:mvcmodel}
\end{figure}

\subsection{PHP Framework}
PHP is a server-side programming language famous for making it simple to develop  web applications in web development, especially in agile methods. 
The Frameworks in various languages like PHP for example are based on MVC with add-ons, i.e. formhelpers and databasecontrollers. 
Frameworks are built to make it even faster to develop a website. 
The biggest PHP Frameworks with MVC-thinking are CodeIgniter and CakePHP.

Codeigniter and CakePHP have many libraries to help the developer. 
Codeigniter has no official inspiration, but its goal is to make it faster for the developer to create good websites rather than creating them from scratch in raw PHP. 
CakePHP is inspired by Ruby on Rails, and you can see that in the structure of how you call the functions in a library in CakePHP. 
The strongest ability of Codeigniter is the openness where the developers can publish libraries and plugins to Codeigniter.
 CakePHP has this ability too, but doesn't have as many followers making requests for changes in the code as Codeigniter.\footnote{This can be shown on their Git (version control system) repositories on Github, \cite{github:codeigniter} and \cite{github:cakephp}, 
a service where followers of the repository can be seen and also how many pull requests each project has.}

The Difference is the structure but basically both are the same. 
They are based on MVC-thinking, but above that both have different structures and different thinking about how the libraries for databases and controllers should behave and be called. 
The biggest difference is the handling of the model. In CakePHP you normally only type the variables, which the model should handle from the database. 
In Codeigniter you build the whole model with variables and functions to get the data from the database. 
You can do that with CakePHP, but by using the already implemented functions in order to get, update, add, and remove data from the table in the database.

\subsection{Client-side}
Client-side means the browser and the scripts and other rendering happening on the visitor`s side on the website. 
This does have a big impact in the performance on a server. \cite{performance:Understanding} 
If using many images, the browser first loads the page and then sends the request to get the images and scripts on the page, adding more load to the server, 
because it generates more requests and thereby increasing the server load. \cite{performance:dynweb}

\subsection{Server-side}
Server-side is the server. Here can the network, CPU, and RAM have an impact on the performance for the visitor on the site. \cite{performance:dynweb} 
When Apache, the server software for http, is getting many requests at the same time, more CPU and RAM will be used and therefore unable to handle all the requests. 
In that case the visitor could experiences the website as slow. 
The network is often what stops more load to the server, because when Apache is optimized it does not use so much of the CPU and RAM, making the CPU and RAM the less of a problem.

\subsection{Performance}
Performances means different things, to keep it simple this paper will be about fast requests.
Performance can also have a big impact on servers, for example a big server park in a data center. 
But, the data center cost a lot of money, which is a problem when experimenting in general.
That is why there will only be tests on cloud with one server in order to see how the framework changes the ms of a request. 
This server is running on Amazon EC2, an isolated server environment on the cloud. 
A good thing with this set-up is that it is more or less how a real website is set-up nowadays, making it more trustworthy in the data. 
The server specification can be seen in Table \ref{table:serverSpecification}.


\section{Research}
\subsection{Research Questions}
\begin{description}
  \item[RQ1:] What kind of web performance evaluations exist and how were they performed?
  \item[RQ2:] What factors impact web performance?\footnote{There is a lack of data on php performance. However there is some data about web performance in general.}
  \item[RQ3:] To what extent are open source php frameworks evaluated?
  \item[RQ4:] What are differences in the performance between the most commonly used open source php frameworks and how can they be evaluated?
\end{description}
My search included more or less different types of strings like ``web development evaluation'' and ``web development performance''. 
In the findings there where 300 papers and of those 8 were relevant because the others were written about the evaluation in general, not about performance in web development. 


\subsection{Research Methodology}
  \begin{tabular}{ l  r }
     
    Research Question & Methodology \\ 
    \hline
    RQ1 & Literature \\ 
    RQ2 & Literature \\
    RQ3 & Literature \\
    RQ4 & Data from RQ1, RQ2 and RQ3 to design experiment \\
  \end{tabular}
\subsection{Literature Survey}
The literature was found in different stages. And the following sources were used:
\begin{itemize}
  \item Google Scholar
  \item IEEE
  \item Google.
\end{itemize}

These strings were used, as seen in Table \ref{table:literaturesearchstrings}.
\begin{table}[htbp]
\centering
\begin{tabular}{ p{6cm}}
  Strings\\
  \hline
  Web development Evaluation \\
  Web development Performance \\
  PHP Framework evaluation \\
  PHP Framework performance \\
  PHP Evaluation \\
  PHP Performance \\
  Website Performance \\
  Website evaluation \\
\end{tabular}
\caption[The strings for searching literature]{The strings for searching literature}
\label{table:literaturesearchstrings}
\end{table}

The search for data was about performance evaluation and the selection of literature research in this field was not plentiful but easy to find.
% FIX!
The important is a good way on  
% END FIX
how they did the research to find out the information in the data, and this was often found in the abstract but sometimes in the background. 
There were often over 300 results in the search, but only up to 1-3 relevant pages in each string, and the same papers were often found in many of the strings.

\section{Literature review}
\subsection{The Approach}
The search was by the strings presented in Table \ref{table:literaturesearchstrings}, and in the search some hundreds of papers were found. 
The question was which approach would be the best by using the strings to find text about such as impact on performance and about performance of PHP. Because of the lack of research in this area it became difficult to find any research about PHP performance at all. However it was easier to find research about web performance in general.
I took everything of value in this area, that had something that could be used for the questions to be answered, such as impact on evaluation tests, php frameworks, different evaluation types and hows. 
The rest of the finding approach depended on the author's ability to find something that had made an impact for a website or something similar that could be an important thing to bring up in this research.

\subsection{The Papers}
In this section there are several papers listed along with descriptions of their contents and what these papers have in common.
\subsubsection{PHP Team Development}
is a book that has its focus on how the MVC idea and techniques make a difference in the development. 
This book has MVC as a big part of PHP development and is about what it does for web development. This book was published in 2009. \cite{MVC:phpTeam}

\subsubsection{Analysis Of Model-based MVC Framework For PHP Development CodeIgniter}
is an analysis of how the MVC based framework Codeigniter is doing in the development of performance and of user ability for developers. 
This is a paper from May 2009 which has much in common with \emph{PHP Team Development}, the book which has a chapter about MVC. \cite{MVC:codeigniter}

\subsubsection{EC2 FAQ: What Is An EC2 Compute Unit}
is a website where the user will find frequently asked questions (FAQ) and answers about EC2 and what a compute unit is. 
This website was last visited in april 2012. \cite{EC2:Amazon}

\subsubsection{Understanding Web Performance}
presents how performance can be used and its importance in the web business. It also brings up how performance can be tested and what can impact the tests. 
It is a paper presented in the Business Communication Review, October 2001. \cite{performance:Understanding}

\subsubsection{A Performance Comparison Of Dynamic Web Technologies}
is paper in which there is a description of the different impacts on performance, comparative analyses of different performance types and how they can be done. Presented in ACM Sigmetrics, December 2003. \cite{performance:dynweb}

\subsubsection{Web-based IDE To Create Model And Controller Components For MVC-Based Web Applications On CakePHP}
is a paper about how the CakePHP is built and how to use it for coding and a little about how MVC works. The paper was published in December 2010. 
It has much in common with the other paper about MVC framework Codeigniter and the book \emph{PHP Team Development.} \cite{MVC:cakephp}


\section{Literature Results}
\subsection{Old Papers}
The results below are based on old papers. 
These papers are based on the general web performance and the web performance has not changed much in 10 years. 
The papers about web performance, less then 10 years old, were difficult to find. 
They were mostly about Java, another programming language, that is not built up in the same way as PHP, making them more or less useless for this paper. 
Impacts and other topics are described in the reviewed papers to help answer the research questions (RQ). This same papers are as important today as when they were published, so the relevance has not changed.

\subsection{RQ1: What kind of web performance evaluations exist and how were they performed?}
Evaluation of the web is mostly done by load testing and counted in ms, but also by  optimizing the page itself to minimize requests to the server, for example by reducing the amount of pictures, or by moving them to another server. 
This can be seen in Table \ref{table:rq1evaluation}.
\begin{table}[htbp]
\centering
\begin{tabular}{ p{4cm} p{3cm} p{2cm} }
  Evaluation Topic & How & Year\\
  \hline
  	requests/ms & experiment & 2001\cite{performance:Understanding,performance:dynweb}\\
  	server/CPU & experiment & 2003 \cite{performance:dynweb} \\
  	on-page optimization & experiment & 2003\cite{performance:dynweb}\\
\end{tabular}
\caption[Different types of evaluation of a web performance]{Different types of evaluation of a web performance}
\label{table:rq1evaluation}
\end{table}

{\bf Request/ms} is mostly used to evaluate performance of web applications. 
There is mention of two different things in two different papers. Firstly,  ``Understanding Performance'' contains the following comment:
\begin{quote}
Sure, speed matters, but it is not a one-dimensional problem. 
And, despite what you have heard, just adding more bandwidth does not always make things go faster. \cite{performance:Understanding}
\end{quote}
Large and many requests need a good Central Processing Unit (CPU) and network, but according to the article ``Understanding Performance'' speed also matters but is not always the only problem. 
Secondly, in ``A Performance Comparison of Dynamic Web Technologies'' tests are done with requests in ms:
\begin{quote}
Consideration of overload behaviour may be just as important as the peak request rate when website administrators are choosing dynamic Web content generation technologies. \cite{performance:dynweb} 
\end{quote}
The researchers understood the importance of choosing the right technologies when using dynamic web content, because of different peaks of requests, creating a need for handling the overload right. The amount and size of requests can change. 
They also show how good it can be to evaluate the performance by using requests per milliseconds or seconds.

{\bf Server/CPU} is important when the server needs to handle many requests at the same time. In ``A Performance Comparison of Dynamic Web Technologies'' the following explanation can be found:
\begin{quote}
Once the servers become overloaded, the CPU utilization of Apache 2.0.45 is lower than that of Apache 1.3.27. 
Under overload, Apache 2.0.45 is unable to accept TCP connections (and hence requests) as quickly as Apache 1.3.27. \cite{performance:dynweb}
\end{quote}
This is important for the CPU to function, but does not mean that Apache itself causes the CPU overload. It can be the network the CPU need to handle, that can causes the CPU overload.

{\bf On-page optimization} is about how to create less requests to the server by removing or grouping several images in one, because browsers load the HTML first and then sends more requests to get the images. 
This also does have something to do with the size of the images, bigger images take more time to download. 
In ``A Performance Comparison of Dynamic Web Technologies'' there are tests done with static content \cite{performance:dynweb} that can be images or normal HTML files. It shows it goes faster than dynamic content, but it is on request.

\subsubsection{The Choice}
will be to use request per ms in the tests, often used in other research experiments and therefore more trustworthy. The tests are to see if it are any difference in the performance from the visitor's perspective, making it less important to evaluate server hardware and on-page optimization, even if the last one is interesting. We need to focus on one thing.
\subsection{RQ2: What factors impact web performance?}
There are things that can have an impact on the performance while testing. The impacts are listed in Table \ref{table:rq2evaluation}.
\begin{table}[htbp]
\centering
\begin{tabular}{ p{2cm} p{3cm} p{7cm} }
  Factor & How It Impacts & Comment\\
  \hline
  	server & network, CPU, RAM & This can be fixed with a large server or a data center, something that can not be tested here.\\
  	\hline
  	network & speed & If the test will perform a request/ms load simulation, the network can be maximized without the server being reaching the performance limit, which has been set already.\\
  	\hline
  	wrong configuration & slowness, bad performance & Wrong configuration on the server, which can result in lower performance, will not be a problem because default configurations will be used, meaning no focus on optimization configurations in this paper.
\end{tabular}
\caption{Different types of evaluation of a web performance}
\label{table:rq2evaluation}
\end{table}

{\bf The server} can have a big impact on performance because the CPU and RAM might not have the ability to handle the big amount of requests tested. 
Small CPU and RAM can make it overload and deny new requests,  
making it impossible to connect when that amount of requests are full.

{\bf The Network} is not very important, but the network should be stable for the amount of requests sent to the server. 
Normal speed would be at least 10mbit down and 10mbit up to send and receive at good speed. 
In my home is for example the stability a problem, making it hard to trust the speed, making the ms higher than it should be. 
For example, the internet connection where the tests were run can have 100 mbit up and 100 mbit down, but only getting 34 mbit of both because of sharing the internet connection with 60 other people. this can have a big impact if alot of people are using the network, but the risk for that is small.

{\bf Wrong configuration} is the thing that can present a problem because many people might not know that it can be a default or a wrong setup configuration that make the server to overload or not accept as many requests as it should. 
The tests will use defaults just to make it as clean as possible, because that is how many people actually are using the defaults in the configurations.

\subsubsection{The Choice}
will be to try to make it more realistic by using server on the cloud with good internet, good hardware, and default configurations.
\newpage
% hilighta fel till the results
\subsection{RQ3: To what extent are open source PHP frameworks evaluated?}
No data were to be found regarding the performance of PHP framework and evaluations thereof. For example other authors could think that this area is covered because the papers on web performance already exist. 
The research is also outdated but there have not been any new inventions in HTML performance either. 
PHP is a script language making it totally different from normal web performance because of the compiling on run, as we can call it.
It means it runs through the PHP code when the file is called. 
It creates a difference in response, 
and then you need to put a PHP Framework over that.
A difference in how you use PHP with libraries in a MVC-pattern could change the response time. 
This is why we will do what we will do in this paper.

\subsubsection{The Choice}
will be to create this paper as a first step in how to do a performance evaluation on PHP Frameworks because of the lack of data in this area.

\section{Experiment Design} 

\subsection{Investigated Question}
Which of CakePHP and Codeigniter provides better performance measured in terms of {\bf page load speed in ms}.

\subsection{Experiment artifacts and variables}


\subsubsection{Controlled Variables,}
the following variables are controlled:
\begin{table}[htbp]
\centering
\begin{tabular}{ p{3cm} p{7cm} }
  	Variable & Description\\
  	\hline
  	request size & Constant\\
  	server & See table \ref{table:serverSpecification}\\
  	framework & Compatible API, look at table \ref{table:classes} for info about the classes.\\
  	response size & Constant. See the size in table \ref{table:thedatafortests}.
\end{tabular}
\caption[Controlled variables in Experiment]{Controlled variables in Experiment}
\label{table:controlledvariables}
\end{table}

The tests are as you can see listed below, and 3 tests will be run on database and 3 tests without database for each framework. It makes 6 tests total for one framework, with and without database.
\begin{table}[htbp]
\centering
\begin{tabular}{l l l l l l}
&\multicolumn{2}{l}{Codeigniter}&\multicolumn{2}{l}{CakePHP}\\
\cline{2-5}
 &Concurrency&Requests&Concurrency&Requests\\
 Test 1 & 5 & 20,000 & 5 & 20,000 & with database\\
 Test 2 & 5 & 20,000 & 5 & 20,000 & with database\\
 Test 3 & 5 & 20,000 & 5 & 20,000 & with database\\
 \hline
 Test 1 & 5 & 20,000 & 5 & 20,000 & without database\\
 Test 2 & 5 & 20,000 & 5 & 20,000 & without database\\
 Test 3 & 5 & 20,000 & 5 & 20,000 & without database\\
\end{tabular}
\caption{How the tests will de done.}
\label{table:testsforframework}
\end{table}
the tests are run on concurrency level 5, i.e. sending 5 requests each time, to be sent as fast as the previous requests are done. This is to help count the response time more exactly. You can see how the tests will be done in Table \ref{table:testsforframework}.

The total amount of the request of 20,000 is to have something to base the average time on, not too much and not too little. 
It does not need to be much more because the average will be the same $\pm$ 2 ms. 
That makes unnecessary to have more. But, it took as many as 20,000 requests in order to show the  right response time in the test results.

A good thing to know is how the server will be setup, and Table \ref{table:serverSpecification} contains the specification of the server that will be used for the experiment on the Amazon cloud.

\begin{table}[htbp]
\centering
\begin{tabular}{ p{4cm}	 p{4cm} }
  System & Version/size \\
  \hline
  OS & Ubuntu 10.04 \\
  Apache & 2.2.14 \\
  MySQL & 5.4 \\
  PHP & 5.3.2 \\
  CPU & 1 EC2 Compute Unit\footnotemark[4] \\
  RAM & 1.7 GB \\
  HDD & 160 GB \\
  bits & 64 bits
\end{tabular}
\caption{The server specification where the test will be done on.}
\label{table:serverSpecification}
\end{table}

In Table \ref{table:classes} can you see how the Framework classes will be used in the experiment.
\footnotetext[4]{One EC2 Compute Unit provides the equivalent CPU capacity of a 1.0-1.2 GHz 2007 Opteron or 2007 Xeon processor. \cite{EC2:Amazon}}
\begin{table}[htbp]
\centering
\begin{tabular}{ p{3cm} p{3cm} p{3cm} }
  Type & Codeigniter class & CakePHP class\\
  \hline
  	Controller & CI\_{}Controller & AppController\\
  	Model & CI\textunderscore{}Model & AppModel\\
	Database & database & database \\
	Form helper & form & Form\\
\end{tabular}
\caption{The different classes to use in the frameworks while coding a blog.}
\label{table:classes}
\end{table}
\subsubsection{Manipulated variables}
\begin{itemize}
  \item {\bf Response Type} HTML without database, HTML with database
  \item Server load measured in terms of {\bf amount of request}
\end{itemize}

Response Type is the only thing that will be changed. 
The database support will be removed or added based on the type of test, making it possible to see the difference in the performance of the core of the framework and the database controller.

\subsubsection{Experiment Artifact}
 {\bf Environment} the server is mostly already set, see Table \ref{table:serverSpecification}.

{\bf Blog} is a simple website with post list on the start page and with its own page for each single post. 
The most important thing about the blog is the index page in the experiment, because it is there the requests will be sent. 
The focus will be on making a decent list of posts on the blog with title, text body, and date of creation. 
Both frameworks are using the same database making it simple and thereby lessening the chance for the database to make a bad impact on the performance. 
You can see the code in appendix A1 and A2.

{\bf Apache benchmark} does the same as all tools for performance for a web application does. 
It is the same idea as sending an amount of requests to the server and counting how long it takes to get the response back. 
Apache benchmark is an tool for benchmarking and has a reputation to do fair tests.\cite{apache:benchmark}

\section{Experiment}
\subsection{How it was made}
Apache benchmark was used to make 20,000 requests on a currency level of 5 to a server. 
The tests were made with a database and randomly picked which framework to test. 
The tests without database were run at different times, creating the difference in the ms in the results.

I used the command line below to send the load request to a randomly picked ip-address\footnote[5]{The ip is typed as 11.11.11.11 to make it clear that the server is not running.} to the test server on the Amazon cloud on Ireland, on different times.
\begin{verbatim}
ab -wn 20000 -c 5 http://11.11.11.11/framework
\end{verbatim}

The variables controlled were response size, amount of request, and currency of requests. 
See the data for the variables in Table \ref{table:thedatafortests}.
\begin{table}[htbp]
\centering
\begin{tabular}{ p{2,6cm} p{2,5cm}  p{2,5cm}  p{2,3cm}  p{2,3cm} }
  {\bf Variable} & Codeigniter db\footnotemark[6] & Codeigniter & CakePHP db\footnotemark[6] & CakePHP \\
  \hline
  {\bf Response size}\footnotemark[7] & 6440000 bytes & 6440000 bytes & 6360000 bytes & 6360000 bytes \\
  {\bf Requests} & 20,000 & 20,000 & 20,000 & 20,000 \\
  {\bf Currency} & 5 & 5 & 5 & 5 \\
\end{tabular}
\caption{The tests with database average request/connection times in ms.}
\label{table:thedatafortests}
\end{table}
\footnotetext[6]{Db means database. i.e. the framework with the database. The database was used with models for posts and without db it was just plain html in view with controller used.}
\footnotetext[7]{Response size is total bytes of data sent from the server in one test on every interval.}
\newpage
\subsection{The results}
The experiment was made randomly at different times. You can see how the tests were done in Table \ref{table:testsforframework}. The results of the tests you can see in Appendix A3.

The results you can see in Figure \ref{fig:experimentwithdb} were almost the same on both, but a small gap between the two frameworks of just a few ms, to be exact it was a gap of 5,34 ms on a average.
\begin{figure}[h]
\includegraphics[scale=0.55]{charts-tests-database.png}
\caption{The average test results with database per request/connection times in ms.}
\label{fig:experimentwithdb}
\end{figure}
\newpage
These tests with database show, if we will focus on the ms total average, the tests run faster with CakePHP. These also need to be tested without database. You can see the result in Figure \ref{fig:experimentwithoutdb}.
\begin{figure}[h]
\includegraphics[scale=0.55]{charts-tests.png}
\caption{The test results without database show the average per request in ms.}
\label{fig:experimentwithoutdb}
\end{figure}

The tests without database show that they are almost equally fast, only 1,3 ms gap between them. This makes CakePHP the fastest in the tests, showing that CakePHP has faster structure on its core.
\subsection{Data analysis and discussion}
It was good to see how different the performance is between the frameworks. 
This is also a good way to evaluate the performance on any web service or application, and the load of request can show how fast the request can be handled by the framework and show the speed it can handle.

The biggest difference in the performance was while using a database. The difference was {\bf 5,34 ms}. It sounds small, but on big sites a few ms do matter. 
When using without database, static files of page were generated from the database-version of the blog with all the posts.
The time difference was {\bf 1,3 ms}, 
almost not noticeable at all.
And, if we take the size into reflection, the gap is even smaller.
Codeigniter might be faster, if the tests were the same size? That could be true. 
The default templates in CakePHP and Codeigniter were used, making the page in different sizes, and could be a difference in the performance of the tests and requests. This was to use the default so the human impact would not influence the tests. It is more secure to use the defaults then trying to have the same sizes. It would be strange to try to have the same sizes because it actually is two different frameworks, making it understandable that there are difference in size.

{\bf The difference in milliseconds} is very small without database because the frameworks seems to have good structure in their core of controllers and support for views, which we did use in the tests without database for both frameworks. 
The difference in ms between the tests using a database is bigger than the difference between the tests using no database, the difference with database was 5,34 ms. It was smaller then anticipated but there was a difference. 
It is noticeable when having a database and the PHP framework on a big website with many visitors. 
In the IT industry, even the small gaps in ms make a big impact because the demand of faster and faster load of the page for a web company. The new user does not have the patience to wait. But it is still a ongoing strategy for websites.
That is why a small difference can be important.

Something to think about is the difference in size, which was around {\bf 80,000 bytes}, for both the tests with and without the database. 
This can create a gap between the frameworks, understandable with database, but without the database the tests were very close to each other. 
If the size was the same, Codeigniter could be faster. 

The difference in the size is because of the use of the default in CakePHP and Codeigniter. CakePHP has more style and a more usable template as default for the application then Codeigniter, and the bigger size of the response can be confusing. 
But the size is not a problem because of the choice to use the default of each framework, which makes the difference in the size. The thinking while doing this tests was to use the defaults because many real websites do the same, making the tests more real. The website of these tests was made to reflect a real website. It creates a more understandable reason to still have the difference in size. The defaults make it more secure and more realistic in the tests. If we try to have the same size for both frameworks we miss the big point which is to have the tests and artifacts as standardized as possible. We decided to focus on the default rather than size, which is why there are size differences in the tests.

The difference in size does not seem to be the problem, and the default tools were used in both frameworks to make a very simple blog website. The size should in other words be different, it would be strange if it was not. 
But keep in mind that the size can make a difference, of course.

Hopefully there will be {\bf future work} done on different and same sizes of the PHP frameworks to see how and if size matters in the performance.

\subsection{Validity Threats}
\subsubsection{Tests are not isolated}
and therefore be disturbed by something from outside. It can be traffic on the Amazon cloud internet connection or something else that can make the response time longer or not trusted. 

But a good thought would be to test the good performance in the real world from a web perspective, to have a web server and a client in various locations to provide realistic data. The goal of this paper is to create as real data as possible, which isolated tests do not give. Isolated tests would, of course, be a dream situation compared to reality.

\subsubsection{Concurrency level} 
could be misunderstood on the low level of 5.
A good thought is that the tests are meant to test how the framework and PHP are handling the requests normally.
Normally it means that 5 users visit the website at the same time.
This number could be bigger or smaller. 
The tests were meant to give a glimpse of how php frameworks act with ``normal'' numbers of visitors, which can, of course, be different for different websites. Therefore, the tests had the exact figure of 5 for the concurrency level to give a sense of several visitors at once.


\subsubsection{Client impact}
could be a problem. The tests were done by Apache benchmark, but Apache benchmark ignores stylesheet and pictures. (The blog in the test did not have pictures.) 
It only gets the generated HTML page after PHP has generate it with the use of the code of a PHP Framework, 
making the impact smaller than a normal browser, which downloads the stylesheets and pictures too.

\section{Conclusion}
There are big differences between the PHP frameworks, but when databases are used the classes using databases could in other words be more effective. 
CakePHP was the fastest in both tests, with and without database, 
but the difference of the size was {\bf 80,000 bytes}. 
This could be something that could make CakePHP a winner, 
but my conclusion is that using default settings on the artifacts give a more realistic test environment rather then focusing on getting the same size on both frameworks.

The fastest framework according to the data is CakePHP with just {\bf 1,3 ms} on average without database and with {\bf 5,34 ms} on average with database. 
This is something that has a big impact on the PHP performance and can be fixed in future versions. 

The experiment shows that the evaluation can be done in ms for websites and web applications. 
These data show that the difference of evaluation between PHP frameworks is not big at all, but there is a difference, even if it is a small one. 

The relevance and contribution of this paper is significant because of the lack of information about and experiments made on PHP frameworks. The PHP framework performance is a new area in the field of technology to hopefully be tested in the future.

Let the war begin between the PHP frameworks.
\newpage
\listofnote
\renewcommand\refname{References}
\bibliographystyle{abbrv}
\bibliography{sigproc} 
\newpage
\section*{Appendix}
\subsection*{A1. CodeIgniter Code}
controller/blog.php
\begin{minted}{php}
<?php
class Blog extends CI_Controller {
	public function __construct()
    {
        parent::__construct();
        $this->load->model('Posts_model', 'Posts', TRUE);
    }
    
    function index() {
    	$this->data->query = $this->Posts->getPosts(10, 0);
    	
    	$this->load->view('blog', $this->data);
    }
    
    function view($id) {
    	$this->data->query = $this->Posts->getPost($id);
    	$this->load->view('view', $this->data);
    }
}
?>
\end{minted}

view/blog.php
\begin{minted}{html}
<html>
<head>
<title>Le Blog</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="/codeigniter/css/cake.generic.css" rel="stylesheet">
<link href="/codeigniter/favicon.ico" type="image/x-icon" rel="icon" />
<link href="/codeigniter/favicon.ico" type="image/x-icon" rel="shortcut icon" />
</head>
<body>
<div style="hight:100px;font-size:18pt;font-family:helvetica,arial;width:100%">
<h1>My simple blog.</h1>
</div>

<div class="container">
<?
if($query->num_rows() > 0) {
	foreach ($query->result() as $row)
	{
		?>
		<div style="width:300px;font-size:8pt">
			<a href="blog/view/<?=$row->id?>">
				<h2><?=$row->title?></h2>
			</a>
		<p>Skrevs <?=$row->created?></p>
		<p><?=$row->body?></p>
		</div>
		<?
	}
}
else {
	?><p>No posts yet.</p><?
}
?>
</div>
</body>
</html>
\end{minted}

view/view.php
\begin{minted}{html}
<html>
<head>
<title>Le Blog</title>
<link href="/codeigniter/bootstrap/css/bootstrap.css" rel="stylesheet">
</head>
<body>
<div style="hight:100px;font-size:18pt;font-family:helvetica,arial;width:100%">
<h1>My simple blog.</h1>
</div>

<div class="container">
<?php
if($query->num_rows() > 0) {
$row = $query->row();
?>
<h2><?=$row->title?></h2>
<p>Created <?=$row->created?></p>
<p><?=$row->body?></p>
<?
}
?>
</div>
</body>
</html>
\end{minted}

model/posts\_{}model.php
\begin{minted}{php}
<?php
class Posts_model extends CI_Model {
	public $id = "";
	public $title = "";
	public $body = "";
	public $created = "";
	public $modified = "";
	
	function install()
	{
			/* First, create our posts table: */
		$this->db->query("CREATE TABLE posts (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(50),
    body TEXT,
    created DATETIME DEFAULT NULL,
    modified DATETIME DEFAULT NULL
);");
	}
	
	function addPost($data) {
    	if($data) {
    		$this->db->insert('posts', $data); 
    	}
	}
	
	function getPosts($amount, $lastId = 0) {
		if($lastId == 0) {
			$data = $this->db->query("SELECT * FROM posts ORDER
			 BY ID DESC LIMIT 10");
		}
		else {
			$data = $this->db->query("SELECT * FROM posts WHERE id
			 <$lastId ORDER BY ID DESC LIMIT 10");
		}
		return $data;
	}
	
	function getPost($id = 0)
	{
		$data = "";
		if($id != 0) {
			$data = $this->db->query("SELECT * FROM posts
			 WHERE id ='{$id}' LIMIT 1");
		}
		return $data;
	}

}
?>
\end{minted}
\subsection*{A2. CakePHP Code}
controller/postsController.php
\begin{minted}{php}
<?php
class PostsController extends AppController {
    public $helpers = array('Html', 'Form');
    
    public function index() {
        $this->set('posts', $this->Post->find('all'));
    }
    
    public function view($id = null) {
    	$this->Post->id = $id;
        $this->set('post', $this->Post->read());
    }
}
?>
\end{minted}
view/posts/index.ctp
\begin{minted}{html}
<!-- File: /app/View/Posts/index.ctp -->

<h1>Blog posts</h1>
<table>
    <tr>
        <th>Id</th>
        <th>Title</th>
        <th>Created</th>
    </tr>

    <!-- Here is where we loop through our $posts array, printing out post info -->

<?php foreach ($posts as $post): ?>
    <tr>
        <td><?php echo $post['Post']['id']; ?></td>
        <td>
            <?php echo $this->Html->link($post['Post']['title'],
array('controller' => 'posts', 'action' => 'view', $post['Post']['id'])); ?>
        </td>
        <td><?php echo $post['Post']['created']; ?></td>
    </tr>
    <?php endforeach; ?>
    
</table>
\end{minted}
view/posts/view.ctp
\begin{minted}{html}

<!-- File: /app/View/Posts/view.ctp -->

<h1><?php echo h($post['Post']['title'])?></h1>

<p><small>Created: <?php echo $post['Post']['created']?></small></p>

<p><?php echo h($post['Post']['body'])?></p>
\end{minted}
model/Post.php
\begin{minted}{php}
<?php
class Post extends AppModel {
	public $validate = array(
        'title' => array(
            'rule' => 'notEmpty'
        ),
        'body' => array(
            'rule' => 'notEmpty'
        )
    );
}
?>
\end{minted}
\subsection*{A3. The Tests Results}
\includepdf[pages=-]{../experiment/tests.pdf} 
\newpage
\includepdf[pages=-]{../experiment/testswithoutdb.pdf}
\end{document}
